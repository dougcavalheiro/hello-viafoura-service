# Hello Viafoura Service

Hello Viafoura Service is a practice codebase that gives a first contact on how Viafoura creates its microservices.

## Before start

Please take a look and get familiar with our [onboarding documentation](https://viafoura.atlassian.net/wiki/spaces/EK/pages/891158537/Developer+Onboarding).
Also it is important to have a clear understanding with [Vert.x](https://viafoura.atlassian.net/wiki/spaces/EK/pages/962854913/Vert.x), 
our main tool-kit to implement reactive / non-blocking Java Rest Services.

## Getting started

The following steps will make some sense while you read and practice them. So, let's rock! 

### 1. What you will see on the way

Our services normally have more than one project/module in their contents. Probably you will see projects with generated
code by reverse engineering provided by Jooq and OpenAPI/Swagger specs and libraries. This project uses openapi specs 
to create the server-side verticles, giving us the job to implement the services in order to work as expected.

### 2. Structure

This is a Gradle project, so you can see in the root directory a Gradle file and other Gradle files for each module. 
You can find other files related to the entire project in the root directory, 
such as docker files readme, and gitignore. The majority of the services follows the following skeleton:

**[service-name]-service**
* **api-generated**: module that enables us to generate a code by an OPEN-API spec.  
  * _src_
    ... Code that is generated by the gradle task
  * _.openapi-generator-ignore_: patterns and files that may be ignored by the openapi generator
  * _build.gradle_: gradle build file responsible for generate the source code by gradle tasks. 
    (for more info, look to the file)
  * _gradle.properties_: Important infos for the code-generation gradle task 
  * _name-service.yaml_: the Openapi spec file
* **main**
  * _src_
    * _main_
      * _java_
        * _com.viafoura.[service-name]_
          * _api)
            * _service_: package that contains the handler classes, responsible for the API implementation 
            * _MainVerticle.java_: The main class, responsible for starting the verticles and services as well.
          * _config_: package with the classes that bind the configurations based on the application.conf / properties file
      * _resources_
        * _application.conf_: This file stores the project's env variables. These variables must be read/bind by the 
          configuration files in the _config_ package mentioned above 
  * _build.gradle_: gradle build configuration and tasks in order to build the project
    
* **build.gradle**: Main project build gradle instructions
* **dependencies_versions.gradle**: Separated file for manage the dependencies and their versions.
* **docker-compose.dependencies.yaml** Docker compose file with dependant services in order to run the application
* **docker-compose.local.yaml** Docker compose file with the entire environment to run locally
* **docker-compose.test.yaml** Docker compose file for functional tests
* **Dockerfile** Build docker file
* **settings.gradle** Gradle settings for the entire project, e.g. what modules will be use in the project
* **Jenkinsfile** The build process for CI/CD 

### 3. Rest API Code generation

The first step when we create a new API endpoint or change an existing one is to modify the openapi spec file.
This file centralizes and documents all necessary resources and their properties for the API. It is also published in
readme.io services in order to provide documentation to our clients. Once you have the api-generated project configured
properly, please go to terminal, in the root project folder execute the following command:

`./gradlew openApiGenerateVertxServerJava`

This command will create or update the server code files for the API implementation. If you look into the 
src/main/java/package-name.server/api/generated/ you will see the API interface for each operationId described 
as you did in the OpenAPI file. Also, you can see other auxiliary files (Models, enums, exceptions) and finally 
the Verticle for each operation too. These verticles have all the vertx implementation for the API, we must only 
implement the API interfaces to provide the real functionality to the service.

You can see more info about code generation in our documentation 
[here](https://viafoura.atlassian.net/wiki/spaces/EK/pages/892207126/Codegeneration+and+Migrating+from+Swagger+2+to+OpenApi+3)

Please, change the _hello_ api in this project and execute the code generation to practice.

### 4. Configurations

As described in the #2 section (Structure) we usually configure as variables the values that may have some significant
change in the different environments (dev/test/production), so it was decided to use 
a [Convention over configuration](https://en.wikipedia.org/wiki/Convention_over_configuration) framework called
Typeface. Typeface helps us to centralize all the configurations from a unique application.conf or 
application.properties file.

It's recommended to create different sections in application.conf file and different config files for each section 
in order to separate their responsibilities and have a clear usage in the dependency injection workflow. For exemple
Database connection, other services connection strings, authorization, etc.

### 5. Modules and dependency injection

For each _subject_ in the service we usually create a package and a module for it. The module class extends the Google's
Guice AbstractModule for its use as dependency injection manager role. Once we have a Module class (e.g. DatabaseModule)
we can implement the constructor of singletons that application may use (e.g. database connection in this case). So, 
by using _javax.inject_ concepts, we are able to use @Singleton, @Provides, @Inject and other features to use in 
any implementations. Finally, we must implement the _getInjector_ method by calling the main module in the application, 
this main module is responsible to "install" the other modules. Please, see 
`main/src/main/java/com.viafoura.helloviafoura/api/ApiServiceModule.java` to have a better understanding of this.

Also, we must write what classes will implement some interfaces in the module classes (Google Guice does not 
do it automatically). In this case, we have to indicate that HelloViafouraOperationHandler.java is the implementation 
class of HelloViafouraOperationApi.java (this one, provided by the api-generated project). 
Take a quick look into the ServiceModule.java class to see the details.

### 6. Running the application

Once all dependencies and implementations finished. You are now able to run the application and do some tests in the 
swagger GUI. For this, create a run configuration pointing to the MainVerticle.java (or just run this file) and 
type in your browser address bar: http://localhost:8080/swagger-ui/index.html.

### Final thoughts

Use this project as a practice one, make some changes / tests in whatever you want to get familiar with our code. 
Also, feel free to suggest new challenges / changes.

#### Welcome to the Viafoura Backend Team.